 //////////////////////////////////////////////////////////////////////////////////////////////////////////
// SelfieBot Base © AlSHex
// 1.0
//
// Create: 27/03/2016
// Modification: 27/03/2016
//
// Description: Software for SelfieBot control. Electronics version Base 1.0
// RU: Описание: Программа управления SelfieBot с электроникой версии Base 1.0
//////////////////////////////////////////////////////////////////////////////////////////////////////////



#include <Servo.h>



// peripherals connecting
// RU: подключение периферии
const int Servo1 = 5; // servo 1 [PWM]
const int Servo2 = 6; // servo 2 [PWM]
const int LED_tech = 13; // technological LED [RU: технологический светодиод]



// declaration and description of modules-functions, pinout and configuration
// RU: объявление и описание модулей-функций, припиновка и настройка
// ===============================
// ========== Interface ==========
// ===============================
const int UART_Speed = 9600; //UART speed

void _Interf_UART(unsigned int RST, unsigned int *Data);
// RST - reset: 0= normal functioning (RU: нормальная работа); 1= reset [RU: сброс]
// Data - command data, control byte array, that the module changes directly in memory
// Ru: Data - данные команды, массив байт управления, которые модуль меняет напрямую в памяти
//
// Connecting to UART occurs via "Serial" Arduino library
// RU: Подсоединение к UART происходит с помощью библиотеки Serial в Arduino

// ===================================
// ========== Control Servo ==========
// ===================================
Servo servo1;
Servo servo2;

void _Control_Servo1(unsigned int Rst, unsigned int Rst_mode, unsigned int Ctrl, unsigned int Mode); // servo for horizontal rotation [RU: сервопривод горизонтального поворота]
void _Control_Servo2(unsigned int Rst, unsigned int Rst_mode, unsigned int Ctrl, unsigned int Mode); // servo for vertical rotation [RU: сервопривод вертикального поворота]
// external control [RU: Внешнее управление]
// RST - reset: 0= normal functioning (RU: нормальная работа); 1= reset [RU: сброс]
// Rst_mode - servo installation type in predetermined position (default): 0 = fast installation (sends the default angle to servo); 1 = smooth installation (adjustable angle is growing slowly at the rate specified in _Control_Servo module parameter) [RU: тип установки сервопривода в заданное положение по умолчанию: 0=быстрая установка (на сервопривод выдаёт угол по умолчанию); 1= плавная установка (устанавливаемый угол нарастает медленно со скоростью, заданной в параметре модуля _Control_Servo)]
// Ctrl - servo control data (command, the execution of which depends on the mode of operation Mode) [RU: Ctrl - данные управления сервоприводами (команда, выполенние которой зависит от режима работы Mode)]
// Mode - mode: 0 = execution of the command considering timer command execution [RU: Mode - режим управления: 0= выполнение команды с учётом таймера времени выполнения команды]
//
// Internal settings [RU: Внутренние настройки]
// - command values to change (increase or decrease) the angles of rotation and to stop rotation [RU: - значения команд для изменения (увеличения или уменьшения) углов поворота и остановки поворота]
const byte Servo1_Cmd_incr = byte('A'); // increasing angle of rotation [RU: увеличения угла поворота]
const byte Servo1_Cmd_decr = byte('D'); // decreasing angle of rotation [RU: уменьшения угла поворота]
const byte Servo1_Cmd_stop = byte('x'); // stops rotation [RU: остановка поворота]
const byte Servo1_Cmd_def = byte('R'); // command to setup default angle Pg_default [RU: команда установки угла по умолчанию Deg_default]
const byte Servo2_Cmd_incr = byte('W'); // increasing angle of rotation [RU: увеличения угла поворота]
const byte Servo2_Cmd_decr = byte('S'); // decreasing angle of rotation [RU: уменьшения угла поворота]
const byte Servo2_Cmd_stop = Servo1_Cmd_stop; // stops rotation [RU: остановка поворота]
const byte Servo2_Cmd_def = Servo1_Cmd_def; // command to setup default angle Pg_default [RU: команда установки угла по умолчанию Deg_default]
// - максимальные и минимальные значения углов, угол поворота выставляемый по умолчанию при сбросе модуля
const int Servo1_Deg_default = 90; // угол поворота по умолчанию
const int Servo1_Deg_min = 0+5; // предельный минимальный угол поворота
const int Servo1_Deg_max = 180-5; // предельный максимальный угол поворота
const int Servo2_Deg_default = Servo1_Deg_default; // угол поворота по умолчанию
const int Servo2_Deg_min = Servo1_Deg_min; // предельный минимальный угол поворота
const int Servo2_Deg_max = Servo1_Deg_max; // предельный максимальный угол поворота
// - скорость поворота: неблокирующая задержка между изменениями углов на 1 градус при повороте, если =0 - задержка не вносится [мс, >=0]
const long Servo1_Time_rotate_deg1 = 0;
const long Servo2_Time_rotate_deg1 = Servo1_Time_rotate_deg1;
// - регулятор скорости поворота при сбросе: блокирующая задержка, т.е. пока не будет установлен заданный угол модуль не даст работать остальной части программы [мс, >0]
const int Servo1_Time_rst = Servo1_Time_rotate_deg1;
const int Servo2_Time_rst = Servo1_Time_rotate_deg1;
// - время актуальности команды на поворот (при Mode=0): после получения однократной команды поворот будет остановлен через заданное время или по получению другой команды [мс, >0]
const long Servo1_Time_rotate = 2;
const long Servo2_Time_rotate = Servo1_Time_rotate;



// ===============================
// ========== MAIN ===============
// ===============================
unsigned int CMD[1] = {0}; // данные от интерфейса, 1 байт



void setup() {

  // первичная настройка доступных пинов
  pinMode(Servo1, OUTPUT); analogWrite(Servo1, 0);
  pinMode(Servo2, OUTPUT); analogWrite(Servo2, 0);
  pinMode(LED_tech, OUTPUT); digitalWrite(LED_tech, LOW);

  
  // начальная инициализация модулей
  Serial.begin(UART_Speed);
  servo1.attach(Servo1);
  servo2.attach(Servo2);

  digitalWrite(LED_tech, HIGH); // индикация инициализации - начало
  _Control_Servo1(1, 1, CMD[0], 0); // установка сервоприводов в положение по умолчанию
  _Control_Servo2(1, 1, CMD[0], 0);
  delay(1000);  
  digitalWrite(LED_tech, LOW); // индикация инициализации - конец

}



void loop() {

  // опрос интерфейса, результат будет доступен в CMD
  _Interf_UART(0, CMD);

  // выполнение схем управления
  _Control_Servo1(0, 1, CMD[0], 0);
  _Control_Servo2(0, 1, CMD[0], 0);

}



// ========== Interface module ==========
void _Interf_UART(unsigned int Rst, unsigned int *Data) { 

unsigned int data_uart;
static unsigned int cnt_byte;

  if (Rst == 0) {
      if (Serial.available() != 0) {
        data_uart = Serial.read();

        switch (cnt_byte) { // проверка целостности пакета, если хоть один сбой - сбрасываем приём и начинаем поиск заголовка нового пакета
          case 0:
            if (data_uart == byte('c')) { cnt_byte++; } else { cnt_byte = 0; }
            Data = 0;
            break;

          case 1:
            if (data_uart == byte('o')) { cnt_byte++; } else { cnt_byte = 0; }
            Data = 0;
            break;
          
          case 2:
            if (data_uart == byte('m')) { cnt_byte++; } else { cnt_byte = 0; }
            Data = 0;
            break;
            
          case 3:
            if (data_uart == byte('=')) { cnt_byte++; } else { cnt_byte = 0; }
            Data = 0;
            break;
            
          case 4: // если дошли до конца, то пакет верен и можно выдать команду
            cnt_byte = 0;
            Data[0] = data_uart;
            break;
            
          default:
            cnt_byte = 0;
            break;            
        }
     } else {
       Data[0] = 0;
     }
  } else {
    cnt_byte = 0;
    Data[0] = 0;
  }
}



// ========== Control Servo1 module ==========
void _Control_Servo1(unsigned int Rst, unsigned int Rst_mode, unsigned int Cmd, unsigned int Mode) {
// Внешнее управление
// Rst - сброс: 0= нормальная работа; 1= сброс
// Rst_mode - тип установки сервопривода в заданное положение по умолчанию: 0=быстрая установка (на сервопривод выдаёт угол по умолчанию); 1= плавная установка (устанавливаемый угол нарастает медленно со скоростью, заданной в параметре модуля _Control_Servo)
// Ctrl - данные управления сервоприводами (команда, выполенние которой зависит от режима работы Mode)
// Mode - режим управления: 0= выполнение команды с учётом таймера времени выполнения команды

// Внутренние настройки
// - значения команд для изменения (увеличения или уменьшения) углов поворота и остановки поворота
const byte Cmd_incr = Servo1_Cmd_incr; // команда увеличения угла поворота
const byte Cmd_decr = Servo1_Cmd_decr; // команда уменьшения угла поворота
const byte Cmd_stop = Servo1_Cmd_stop; // команда остановка поворота
const byte Cmd_def = Servo1_Cmd_def; // команда установки угла по умолчанию Deg_default
// - максимальные и минимальные значения углов, угол поворота выставляемый по умолчанию при сбросе модуля
const int Deg_default = Servo1_Deg_default; // угол поворота по умолчанию
const int Deg_min = Servo1_Deg_min; // предельный минимальный угол поворота
const int Deg_max = Servo1_Deg_max; // предельный максимальный угол поворота
// - скорость поворота: неблокирующая задержка между изменениями углов на 1 градус при повороте, если =0 - задержка не вносится [мс, >=0]
const long Time_rotate_deg1 = Servo1_Time_rotate_deg1;
// - регулятор скорости поворота при сбросе: блокирующая задержка, т.е. пока не будет установлен заданный угол модуль не даст работать остальной части программы [мс, >0]
const int Time_rst = Servo1_Time_rst;
// - время актуальности команды на поворот (при Mode=0): после получения однократной команды поворот будет остановлен через заданное время или по получению другой команды [мс, >0]
const long Time_rotate = Servo1_Time_rotate;

static signed int deg; // угол поворота на сервопривод
static unsigned int incr, decr; // управляющие сигналы для алгоритма совершения поворота
static unsigned long time_cmd_detect, time_rotate_detect = 0; // значение времени получения команды и времени последнего изменёния угла поворота

  if (Rst == 0 & Cmd != Cmd_def) {
 
    if (Mode == 0) { // выполнение команды с учётом таймера времени выполнения команды
      if (Cmd == Cmd_incr) {
        incr = 1;
        decr = 0;
        time_cmd_detect = millis();
      } else if (Cmd == Cmd_decr) {
        incr = 0;
        decr = 1;
        time_cmd_detect = millis();
      } else if (Cmd == Cmd_stop) {
        incr = 0;
        decr = 0;      
      }

      if (millis() - time_cmd_detect > Time_rotate) {
        incr = 0;
        decr = 0;
      }
    }

    if (Time_rotate_deg1 == 0) { // алгоритм поворота
        if (incr == 1) {
          if (deg < Deg_max) { deg++; } // поворачиваем к 180
        } else if (decr == 1) { 
          if (deg > Deg_min) { deg--; } // поворачиваем к 0
        }
        servo1.write(deg);
    } else {
      if (millis() - time_rotate_detect > Time_rotate_deg1) { // задержка при повороте - регулирование скорости поворота
        if (incr == 1) {
          if (deg < Deg_max) { // поворачиваем к 180
            deg++;
            time_rotate_detect = millis();
          }
        } else if (decr == 1) { // поворачиваем к 0
          if (deg > Deg_min) {
            deg--;
            time_rotate_detect = millis();
          }
        }
        servo1.write(deg);
      }
    }
    
  } else {

    // установка по умолчанию
    while (deg != Deg_default) {
      if (Rst_mode == 0) {
        servo1.write(Deg_default);
        deg = Deg_default;
      } else {
        if (deg < Deg_default) { deg++; } else { deg--; }
        servo1.write(deg);
        delay(Time_rst);
      }
    }

    incr = 0;
    decr = 0;
  }
}



// ========== Control Servo2 module ==========
void _Control_Servo2(unsigned int Rst, unsigned int Rst_mode, unsigned int Cmd, unsigned int Mode) {
// Внешнее управление
// Rst - сброс: 0= нормальная работа; 1= сброс
// Rst_mode - тип установки сервопривода в заданное положение по умолчанию: 0=быстрая установка (на сервопривод выдаёт угол по умолчанию); 1= плавная установка (устанавливаемый угол нарастает медленно со скоростью, заданной в параметре модуля _Control_Servo)
// Ctrl - данные управления сервоприводами (команда, выполенние которой зависит от режима работы Mode)
// Mode - режим управления: 0= выполнение команды с учётом таймера времени выполнения команды

// Внутренние настройки
// - значения команд для изменения (увеличения или уменьшения) углов поворота и остановки поворота
const byte Cmd_incr = Servo2_Cmd_incr; // команда увеличения угла поворота
const byte Cmd_decr = Servo2_Cmd_decr; // команда уменьшения угла поворота
const byte Cmd_stop = Servo2_Cmd_stop; // каманда остановки поворота
const byte Cmd_def = Servo2_Cmd_def; // команда установки угла по умолчанию Deg_default
// - максимальные и минимальные значения углов, угол поворота выставляемый по умолчанию при сбросе модуля
const int Deg_default = Servo2_Deg_default; // угол поворота по умолчанию
const int Deg_min = Servo2_Deg_min; // предельный минимальный угол поворота
const int Deg_max = Servo2_Deg_max; // предельный максимальный угол поворота
// - скорость поворота: неблокирующая задержка между изменениями углов на 1 градус при повороте, если =0 - задержка не вносится [мс, >=0]
const long Time_rotate_deg1 = Servo2_Time_rotate_deg1;
// - регулятор скорости поворота при сбросе: блокирующая задержка, т.е. пока не будет установлен заданный угол модуль не даст работать остальной части программы [мс, >0]
const int Time_rst = Servo2_Time_rst;
// - время актуальности команды на поворот (при Mode=0): после получения однократной команды поворот будет остановлен через заданное время или по получению другой команды [мс, >0]
const long Time_rotate = Servo2_Time_rotate;

static unsigned int deg; // угол поворота на сервопривод
static unsigned int incr, decr; // управляющие сигналы для алгоритма совершения поворота
static unsigned long time_cmd_detect, time_rotate_detect = 0; // значение времени получения команды и времени последнего изменёния угла поворота

  if (Rst == 0 & Cmd != Cmd_def) {
 
    if (Mode == 0) { // выполнение команды с учётом таймера времени выполнения команды
      if (Cmd == Cmd_incr) {
        incr = 1;
        decr = 0;
        time_cmd_detect = millis();
      } else if (Cmd == Cmd_decr) {
        incr = 0;
        decr = 1;
        time_cmd_detect = millis();
      } else if (Cmd == Cmd_stop) {
        incr = 0;
        decr = 0;
      }

      if (millis() - time_cmd_detect > Time_rotate) {
        incr = 0;
        decr = 0;
      }
    }

    if (Time_rotate_deg1 == 0) { // алгоритм поворота
        if (incr == 1) {
          if (deg < Deg_max) { deg++; } // поворачиваем к 180
        } else if (decr == 1) { 
          if (deg > Deg_min) { deg--; } // поворачиваем к 0
        }
        servo2.write(deg);
    } else {
      if (millis() - time_rotate_detect > Time_rotate_deg1) { // задержка при повороте - регулирование скорости поворота
        if (incr == 1) {
          if (deg < Deg_max) { // поворачиваем к 180
            deg++;
            time_rotate_detect = millis();
          }
        } else if (decr == 1) { // поворачиваем к 0
          if (deg > Deg_min) {
            deg--;
            time_rotate_detect = millis();
          }
        }
        servo2.write(deg);
      }
    }
    
  } else {

    // установка по умолчанию
    while (deg != Deg_default) {
      if (Rst_mode == 0) {
        servo2.write(Deg_default);
        deg = Deg_default;
      } else {
        if (deg < Deg_default) { deg++; } else { deg--; }
        servo2.write(deg);
        delay(Time_rst);
      }
    }

    incr = 0;
    decr = 0;
  }
}
